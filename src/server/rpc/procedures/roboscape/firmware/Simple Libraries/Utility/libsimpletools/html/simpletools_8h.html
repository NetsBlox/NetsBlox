<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>simpletools library: simpletools.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ParallaxLogo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">simpletools library
   &#160;<span id="projectnumber">v1.1.8</span>
   </div>
   <div id="projectbrief">Collection of convenience functions for common microcontroller tasks</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">simpletools.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This library provides convenient functions for a variety of microcontroller I/O, timing, conversion, and communication tasks. This library also includes (and you can call functions from) <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20simpletext%20Library.html" target="blank">simpletext</a> and <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20serial%20Library.html" target="blank">serial</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;propeller.h&gt;</code><br />
<code>#include &quot;simpletext.h&quot;</code><br />
<code>#include &lt;driver.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;cog.h&gt;</code><br />
<code>#include &lt;ctype.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;sys/stat.h&gt;</code><br />
<code>#include &lt;dirent.h&gt;</code><br />
<code>#include &lt;sys/sd.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &quot;simplei2c.h&quot;</code><br />
</div>
<p><a href="simpletools_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a598a3330b3c21701223ee0ca14316eca"><td class="memItemLeft" align="right" valign="top"><a id="a598a3330b3c21701223ee0ca14316eca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a598a3330b3c21701223ee0ca14316eca">PI</a>&#160;&#160;&#160;3.141592653589793</td></tr>
<tr class="memdesc:a598a3330b3c21701223ee0ca14316eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">3.141592653589793 <br /></td></tr>
<tr class="separator:a598a3330b3c21701223ee0ca14316eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SimpleIDE Terminal Constants</div></td></tr>
<tr class="memitem:a0e26ea2db1b570d1a6fe1ac180ef4541"><td class="memItemLeft" align="right" valign="top"><a id="a0e26ea2db1b570d1a6fe1ac180ef4541"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a0e26ea2db1b570d1a6fe1ac180ef4541">HOME</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="memdesc:a0e26ea2db1b570d1a6fe1ac180ef4541"><td class="mdescLeft">&#160;</td><td class="mdescRight">HOME character (1) sends SimpleIDE Terminal's cursor to top-left "home" position. <br /></td></tr>
<tr class="separator:a0e26ea2db1b570d1a6fe1ac180ef4541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa53bcf09725cf1948b70eaaa229a3d1"><td class="memItemLeft" align="right" valign="top"><a id="afa53bcf09725cf1948b70eaaa229a3d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#afa53bcf09725cf1948b70eaaa229a3d1">CRSRXY</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="memdesc:afa53bcf09725cf1948b70eaaa229a3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRXY character (2) sends cursor to a certain number of spaces over (X) and returns (Y) down from SimpleIDE Terminal's top-left HOME position. This character has to be followed immediately by the X and Y values when transmitted to the SimpleIDE Terminal. <br /></td></tr>
<tr class="separator:afa53bcf09725cf1948b70eaaa229a3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e599685cbc5af2bb2a3baffdf881dff"><td class="memItemLeft" align="right" valign="top"><a id="a9e599685cbc5af2bb2a3baffdf881dff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a9e599685cbc5af2bb2a3baffdf881dff">CRSRLF</a>&#160;&#160;&#160;(3)</td></tr>
<tr class="memdesc:a9e599685cbc5af2bb2a3baffdf881dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRLF character (3) sends the SimpleIDE Terminal's cursor one column (space) to the left of its current position. <br /></td></tr>
<tr class="separator:a9e599685cbc5af2bb2a3baffdf881dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf84697e36358569284ae174db49051"><td class="memItemLeft" align="right" valign="top"><a id="acaf84697e36358569284ae174db49051"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#acaf84697e36358569284ae174db49051">CRSRRT</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:acaf84697e36358569284ae174db49051"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRRT character (4) sends the SimpleIDE Terminal's cursor one column (space) to the right of its current position. <br /></td></tr>
<tr class="separator:acaf84697e36358569284ae174db49051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda2c79c6638bf0c75ce50209da388a"><td class="memItemLeft" align="right" valign="top"><a id="a2fda2c79c6638bf0c75ce50209da388a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2fda2c79c6638bf0c75ce50209da388a">CRSRUP</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="memdesc:a2fda2c79c6638bf0c75ce50209da388a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRUP character (5) sends the SimpleIDE Terminal's cursor one row (carriage return) upward from its current position. <br /></td></tr>
<tr class="separator:a2fda2c79c6638bf0c75ce50209da388a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b2cacea568fc44982a68a31da8757f"><td class="memItemLeft" align="right" valign="top"><a id="a01b2cacea568fc44982a68a31da8757f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a01b2cacea568fc44982a68a31da8757f">CRSRDN</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="memdesc:a01b2cacea568fc44982a68a31da8757f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRDN character (6) sends the SimpleIDE Terminal's cursor one row (carriage return) downward from its current position. <br /></td></tr>
<tr class="separator:a01b2cacea568fc44982a68a31da8757f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceb0e81b845fdcd1b8371e92229a13b"><td class="memItemLeft" align="right" valign="top"><a id="a1ceb0e81b845fdcd1b8371e92229a13b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1ceb0e81b845fdcd1b8371e92229a13b">BEEP</a>&#160;&#160;&#160;(7)</td></tr>
<tr class="memdesc:a1ceb0e81b845fdcd1b8371e92229a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BEEP character (7) makes the system speaker in some computers beep when received by SimpleIDE Terminal. <br /></td></tr>
<tr class="separator:a1ceb0e81b845fdcd1b8371e92229a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f41e5dc4d1d256277cb259077da1fc6"><td class="memItemLeft" align="right" valign="top"><a id="a4f41e5dc4d1d256277cb259077da1fc6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a4f41e5dc4d1d256277cb259077da1fc6">BKSP</a>&#160;&#160;&#160;(8)</td></tr>
<tr class="memdesc:a4f41e5dc4d1d256277cb259077da1fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">BKSP character (8) sends the SimpleIDE Terminal's cursor one column (space) to the left of its current position and erases whatever character was there. <br /></td></tr>
<tr class="separator:a4f41e5dc4d1d256277cb259077da1fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58a1fbfc85c7e4790fc55e654f50221"><td class="memItemLeft" align="right" valign="top"><a id="ad58a1fbfc85c7e4790fc55e654f50221"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ad58a1fbfc85c7e4790fc55e654f50221">TAB</a>&#160;&#160;&#160;(9)</td></tr>
<tr class="memdesc:ad58a1fbfc85c7e4790fc55e654f50221"><td class="mdescLeft">&#160;</td><td class="mdescRight">TAB character (9) advances the cursor to the right by a tab's worth of spaces. <br /></td></tr>
<tr class="separator:ad58a1fbfc85c7e4790fc55e654f50221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="memItemLeft" align="right" valign="top"><a id="a4fc34b120ed3bd1120c1eb36abbcd6af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a4fc34b120ed3bd1120c1eb36abbcd6af">NL</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">NL character (10) sends the SimpleIDE Terminal's cursor to the leftmost character in the next line down. <br /></td></tr>
<tr class="separator:a4fc34b120ed3bd1120c1eb36abbcd6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350c9d6cb81908d59427ee96844d1a9c"><td class="memItemLeft" align="right" valign="top"><a id="a350c9d6cb81908d59427ee96844d1a9c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a350c9d6cb81908d59427ee96844d1a9c">LF</a>&#160;&#160;&#160;(10)</td></tr>
<tr class="memdesc:a350c9d6cb81908d59427ee96844d1a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LF is same as NL. <br /></td></tr>
<tr class="separator:a350c9d6cb81908d59427ee96844d1a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f56dd6f32ebc7b504090212600d922"><td class="memItemLeft" align="right" valign="top"><a id="ac2f56dd6f32ebc7b504090212600d922"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac2f56dd6f32ebc7b504090212600d922">CLREOL</a>&#160;&#160;&#160;(11)</td></tr>
<tr class="memdesc:ac2f56dd6f32ebc7b504090212600d922"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLREOL character (11) erases all SimpleIDE Terminal characters to the right of the cursor. <br /></td></tr>
<tr class="separator:ac2f56dd6f32ebc7b504090212600d922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdb24d24f81764bea8c96fe07d48e0a"><td class="memItemLeft" align="right" valign="top"><a id="a1cdb24d24f81764bea8c96fe07d48e0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1cdb24d24f81764bea8c96fe07d48e0a">CLRDN</a>&#160;&#160;&#160;(12)</td></tr>
<tr class="memdesc:a1cdb24d24f81764bea8c96fe07d48e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLRDN character (12) erases all SimpleIDE Terminal characters below the cursor. <br /></td></tr>
<tr class="separator:a1cdb24d24f81764bea8c96fe07d48e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876ce77f3c672c7162658151e648389e"><td class="memItemLeft" align="right" valign="top"><a id="a876ce77f3c672c7162658151e648389e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a876ce77f3c672c7162658151e648389e">CR</a>&#160;&#160;&#160;(13)</td></tr>
<tr class="memdesc:a876ce77f3c672c7162658151e648389e"><td class="mdescLeft">&#160;</td><td class="mdescRight">CR character (13) sends SimpleIDE Terminal's cursor one row downward. <br /></td></tr>
<tr class="separator:a876ce77f3c672c7162658151e648389e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf3d7ff85aa894ae161d3f7ced308f1"><td class="memItemLeft" align="right" valign="top"><a id="a3cf3d7ff85aa894ae161d3f7ced308f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a3cf3d7ff85aa894ae161d3f7ced308f1">CRSRX</a>&#160;&#160;&#160;(14)</td></tr>
<tr class="memdesc:a3cf3d7ff85aa894ae161d3f7ced308f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRX character (14) positions SimpleIDE Terminal's cursor X characters from the its left edge. <br /></td></tr>
<tr class="separator:a3cf3d7ff85aa894ae161d3f7ced308f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af522fc6b22b3ec6d30fa9e5462d925e5"><td class="memItemLeft" align="right" valign="top"><a id="af522fc6b22b3ec6d30fa9e5462d925e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af522fc6b22b3ec6d30fa9e5462d925e5">CRSRY</a>&#160;&#160;&#160;(15)</td></tr>
<tr class="memdesc:af522fc6b22b3ec6d30fa9e5462d925e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRSRY character (15) sends SimpleIDE Terminal's cursor Y rows to the from its top edge. <br /></td></tr>
<tr class="separator:af522fc6b22b3ec6d30fa9e5462d925e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada59561816893aa39c4aa41f1043c554"><td class="memItemLeft" align="right" valign="top"><a id="ada59561816893aa39c4aa41f1043c554"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ada59561816893aa39c4aa41f1043c554">CLS</a>&#160;&#160;&#160;(16)</td></tr>
<tr class="memdesc:ada59561816893aa39c4aa41f1043c554"><td class="mdescLeft">&#160;</td><td class="mdescRight">CLS character (16) clears SimpleIDE's screen, erasing all characters and placing the cursor in the top-left corner. <br /></td></tr>
<tr class="separator:ada59561816893aa39c4aa41f1043c554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SPI Constants for shift_in &amp; shift_out</div></td></tr>
<tr class="memitem:a0a50888a81959bc58f01b49ec0f8c961"><td class="memItemLeft" align="right" valign="top"><a id="a0a50888a81959bc58f01b49ec0f8c961"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a0a50888a81959bc58f01b49ec0f8c961">MSBPRE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a0a50888a81959bc58f01b49ec0f8c961"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_in. Stands for most significant bit first, pre-clock. <br /></td></tr>
<tr class="separator:a0a50888a81959bc58f01b49ec0f8c961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0275a42546f7deb25aafca03ccadca"><td class="memItemLeft" align="right" valign="top"><a id="acd0275a42546f7deb25aafca03ccadca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#acd0275a42546f7deb25aafca03ccadca">LSBPRE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:acd0275a42546f7deb25aafca03ccadca"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_in. Stands for least significant bit first, pre-clock. <br /></td></tr>
<tr class="separator:acd0275a42546f7deb25aafca03ccadca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e82bb8e633953523a7b78de640174b"><td class="memItemLeft" align="right" valign="top"><a id="a08e82bb8e633953523a7b78de640174b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a08e82bb8e633953523a7b78de640174b">MSBPOST</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a08e82bb8e633953523a7b78de640174b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_in. Stands for most significant bit first, post-clock. <br /></td></tr>
<tr class="separator:a08e82bb8e633953523a7b78de640174b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55f183bf537941b4ef0b09655a560b2"><td class="memItemLeft" align="right" valign="top"><a id="af55f183bf537941b4ef0b09655a560b2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af55f183bf537941b4ef0b09655a560b2">LSBPOST</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:af55f183bf537941b4ef0b09655a560b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_in. Stands for least significant bit first, post-clock. <br /></td></tr>
<tr class="separator:af55f183bf537941b4ef0b09655a560b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5811613d98580676f67f0dde8125433e"><td class="memItemLeft" align="right" valign="top"><a id="a5811613d98580676f67f0dde8125433e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a5811613d98580676f67f0dde8125433e">LSBFIRST</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a5811613d98580676f67f0dde8125433e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_out. Stands for least significant bit first. <br /></td></tr>
<tr class="separator:a5811613d98580676f67f0dde8125433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ef42eff02618bde70868af4944d81"><td class="memItemLeft" align="right" valign="top"><a id="a1c7ef42eff02618bde70868af4944d81"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1c7ef42eff02618bde70868af4944d81">MSBFIRST</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1c7ef42eff02618bde70868af4944d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use with shift_out. Stands for most significant bit first. <br /></td></tr>
<tr class="separator:a1c7ef42eff02618bde70868af4944d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Counter Module Constants</div></td></tr>
<tr class="memitem:a4dbd6ec520f6a6b4e4610cc804c05fe8"><td class="memItemLeft" align="right" valign="top"><a id="a4dbd6ec520f6a6b4e4610cc804c05fe8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a4dbd6ec520f6a6b4e4610cc804c05fe8">NCO_PWM_1</a>&#160;&#160;&#160;(0b00100 &lt;&lt; 26)</td></tr>
<tr class="memdesc:a4dbd6ec520f6a6b4e4610cc804c05fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building block for configuring a cog's counter module to PWM mode. Used by pwm functions. PWM stands for pulse width modulation. <br /></td></tr>
<tr class="separator:a4dbd6ec520f6a6b4e4610cc804c05fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f32a431c48e36da66f94897013ff09"><td class="memItemLeft" align="right" valign="top"><a id="af4f32a431c48e36da66f94897013ff09"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af4f32a431c48e36da66f94897013ff09">CTR_NCO</a>&#160;&#160;&#160;(0b100 &lt;&lt; 26)</td></tr>
<tr class="memdesc:af4f32a431c48e36da66f94897013ff09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building block for configuring a cog's counter module to NCO mode. Used by square_wave function. NCO stands for numerically controlled oscillator. <br /></td></tr>
<tr class="separator:af4f32a431c48e36da66f94897013ff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35343305570a7f0c402035a61ac54562"><td class="memItemLeft" align="right" valign="top"><a id="a35343305570a7f0c402035a61ac54562"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a35343305570a7f0c402035a61ac54562">CTR_PLL</a>&#160;&#160;&#160;(0b10 &lt;&lt; 26)</td></tr>
<tr class="memdesc:a35343305570a7f0c402035a61ac54562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building block for configuring a cog's counter module to PLL mode. Used by square_wave function. PLL stands for phase locked loop. <br /></td></tr>
<tr class="separator:a35343305570a7f0c402035a61ac54562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e7c6583ebf1d8f9c2d2c32bbf0c984"><td class="memItemLeft" align="right" valign="top"><a id="a83e7c6583ebf1d8f9c2d2c32bbf0c984"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a83e7c6583ebf1d8f9c2d2c32bbf0c984">DUTY_SE</a>&#160;&#160;&#160;(0b110 &lt;&lt; 26)</td></tr>
<tr class="memdesc:a83e7c6583ebf1d8f9c2d2c32bbf0c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Building block for configuring a cog's counter module to DUTY_SE mode. Used by dac functions. DUTY_SE stands for duty single ended. <br /></td></tr>
<tr class="separator:a83e7c6583ebf1d8f9c2d2c32bbf0c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reverse Compatibility Functions</div></td></tr>
<tr class="memitem:ac04aea26e16ed3b740d27bc03eed2db5"><td class="memItemLeft" align="right" valign="top"><a id="ac04aea26e16ed3b740d27bc03eed2db5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac04aea26e16ed3b740d27bc03eed2db5">ee_put_byte</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#a593162b2f71e2ad23f0a09516cf9a7b4">ee_putByte</a></td></tr>
<tr class="memdesc:ac04aea26e16ed3b740d27bc03eed2db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_byte renamed ee_putByte. <br /></td></tr>
<tr class="separator:ac04aea26e16ed3b740d27bc03eed2db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4945cabc87fb08d37fca7e0db20422"><td class="memItemLeft" align="right" valign="top"><a id="aae4945cabc87fb08d37fca7e0db20422"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aae4945cabc87fb08d37fca7e0db20422">ee_get_byte</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#ac1042df969c1f5bffa816fdf068c4ed9">ee_getByte</a></td></tr>
<tr class="memdesc:aae4945cabc87fb08d37fca7e0db20422"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_byte renamed ee_getByte. <br /></td></tr>
<tr class="separator:aae4945cabc87fb08d37fca7e0db20422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd0c9e763b2c99590bde1206b8f49e0"><td class="memItemLeft" align="right" valign="top"><a id="a1dd0c9e763b2c99590bde1206b8f49e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1dd0c9e763b2c99590bde1206b8f49e0">ee_put_int</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#adf44a20755432a25076e28e94b809264">ee_putInt</a></td></tr>
<tr class="memdesc:a1dd0c9e763b2c99590bde1206b8f49e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_int renamed ee_putInt. <br /></td></tr>
<tr class="separator:a1dd0c9e763b2c99590bde1206b8f49e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbbc5e22a078c75b316d08fe6739509"><td class="memItemLeft" align="right" valign="top"><a id="a6cbbc5e22a078c75b316d08fe6739509"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a6cbbc5e22a078c75b316d08fe6739509">ee_get_int</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#ad5ba1e74fdbc69a0578425eb5e176461">ee_getInt</a></td></tr>
<tr class="memdesc:a6cbbc5e22a078c75b316d08fe6739509"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_int renamed ee_getInt. <br /></td></tr>
<tr class="separator:a6cbbc5e22a078c75b316d08fe6739509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59386353f20e5a9688e189423fbcfc85"><td class="memItemLeft" align="right" valign="top"><a id="a59386353f20e5a9688e189423fbcfc85"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a59386353f20e5a9688e189423fbcfc85">ee_put_str</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#ab958571c584ab8d846c3a8a2cb326109">ee_putStr</a></td></tr>
<tr class="memdesc:a59386353f20e5a9688e189423fbcfc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_str renamed ee_putStr. <br /></td></tr>
<tr class="separator:a59386353f20e5a9688e189423fbcfc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2ae1a4f7d1f422c346687845979b7f"><td class="memItemLeft" align="right" valign="top"><a id="a2c2ae1a4f7d1f422c346687845979b7f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2c2ae1a4f7d1f422c346687845979b7f">ee_get_str</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#a6e3fa8a82d1bc2be0828314652debe26">ee_getStr</a></td></tr>
<tr class="memdesc:a2c2ae1a4f7d1f422c346687845979b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_get_str renamed ee_getStr. <br /></td></tr>
<tr class="separator:a2c2ae1a4f7d1f422c346687845979b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6e9570f4721c1a580299bdb80638d5"><td class="memItemLeft" align="right" valign="top"><a id="a9d6e9570f4721c1a580299bdb80638d5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a9d6e9570f4721c1a580299bdb80638d5">ee_put_float32</a>&#160;&#160;&#160;<a class="el" href="simpletools_8h.html#a10a9a5cd4767ffd7a82c9acd2b9485b2">ee_putFloat32</a></td></tr>
<tr class="memdesc:a9d6e9570f4721c1a580299bdb80638d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ee_put_float32 renamed ee_putFloat32. <br /></td></tr>
<tr class="separator:a9d6e9570f4721c1a580299bdb80638d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9241e417ac6f468979cc60b0263d49f"><td class="memItemLeft" align="right" valign="top"><a id="af9241e417ac6f468979cc60b0263d49f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af9241e417ac6f468979cc60b0263d49f">pause_ticks</a>(pticks)&#160;&#160;&#160;__builtin_propeller_waitcnt(pticks+CNT, 0)</td></tr>
<tr class="memdesc:af9241e417ac6f468979cc60b0263d49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated) Use waitcnt(CLKFREQ + CNT) for a delay that lasts 1 second, and use fractions of CLKFREQ for smaller numbers of system clock ticks. <br /></td></tr>
<tr class="separator:af9241e417ac6f468979cc60b0263d49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Propeller EEPROM Address</div></td></tr>
<tr class="memitem:a95a8626764b7fcbf81fddaa0a197def8"><td class="memItemLeft" align="right" valign="top"><a id="a95a8626764b7fcbf81fddaa0a197def8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a95a8626764b7fcbf81fddaa0a197def8">EEPROM_ADDR</a>&#160;&#160;&#160;0x50</td></tr>
<tr class="memdesc:a95a8626764b7fcbf81fddaa0a197def8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propeller EEPROM I2C bus address. <br /></td></tr>
<tr class="separator:a95a8626764b7fcbf81fddaa0a197def8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d9825708f3b6cae156e4e5f1e1647f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a4d9825708f3b6cae156e4e5f1e1647f6">high</a> (int pin)</td></tr>
<tr class="memdesc:a4d9825708f3b6cae156e4e5f1e1647f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to output-high.  <a href="#a4d9825708f3b6cae156e4e5f1e1647f6">More...</a><br /></td></tr>
<tr class="separator:a4d9825708f3b6cae156e4e5f1e1647f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b4677f42acfb2273127492d13a7e05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ab6b4677f42acfb2273127492d13a7e05">low</a> (int pin)</td></tr>
<tr class="memdesc:ab6b4677f42acfb2273127492d13a7e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to output-low.  <a href="#ab6b4677f42acfb2273127492d13a7e05">More...</a><br /></td></tr>
<tr class="separator:ab6b4677f42acfb2273127492d13a7e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b2c5f5c8559b5f2957239f2c2e663d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af2b2c5f5c8559b5f2957239f2c2e663d">input</a> (int pin)</td></tr>
<tr class="memdesc:af2b2c5f5c8559b5f2957239f2c2e663d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to input and return 1 if pin detects a high signal, or 0 if it detects low.  <a href="#af2b2c5f5c8559b5f2957239f2c2e663d">More...</a><br /></td></tr>
<tr class="separator:af2b2c5f5c8559b5f2957239f2c2e663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">More Individual I/O</div></td></tr>
<tr class="memitem:ac00aa846d252ba311694febd1100bd11"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac00aa846d252ba311694febd1100bd11">toggle</a> (int pin)</td></tr>
<tr class="memdesc:ac00aa846d252ba311694febd1100bd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the output state of the I/O pin.  <a href="#ac00aa846d252ba311694febd1100bd11">More...</a><br /></td></tr>
<tr class="separator:ac00aa846d252ba311694febd1100bd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4291907fc0563f65a1f3ed85fb878d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#abe4291907fc0563f65a1f3ed85fb878d">reverse</a> (int pin)</td></tr>
<tr class="memdesc:abe4291907fc0563f65a1f3ed85fb878d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the direction of an I/O pin.  <a href="#abe4291907fc0563f65a1f3ed85fb878d">More...</a><br /></td></tr>
<tr class="separator:abe4291907fc0563f65a1f3ed85fb878d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f77582253a5ee75241615296dcf0d05"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a9f77582253a5ee75241615296dcf0d05">get_state</a> (int pin)</td></tr>
<tr class="memdesc:a9f77582253a5ee75241615296dcf0d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the state of an I/O pin without setting it to input.  <a href="#a9f77582253a5ee75241615296dcf0d05">More...</a><br /></td></tr>
<tr class="separator:a9f77582253a5ee75241615296dcf0d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e6b702137ad730e834bce8a114a550"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aa3e6b702137ad730e834bce8a114a550">get_direction</a> (int pin)</td></tr>
<tr class="memdesc:aa3e6b702137ad730e834bce8a114a550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the direction of the I/O pin.  <a href="#aa3e6b702137ad730e834bce8a114a550">More...</a><br /></td></tr>
<tr class="separator:aa3e6b702137ad730e834bce8a114a550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf05ad4f74447ecbb557b4ee0c190e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1faf05ad4f74447ecbb557b4ee0c190e">get_output</a> (int pin)</td></tr>
<tr class="memdesc:a1faf05ad4f74447ecbb557b4ee0c190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get I/O pin output state.  <a href="#a1faf05ad4f74447ecbb557b4ee0c190e">More...</a><br /></td></tr>
<tr class="separator:a1faf05ad4f74447ecbb557b4ee0c190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c13d6b776c998bd74286c6a8b774dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a97c13d6b776c998bd74286c6a8b774dd">set_direction</a> (int pin, int direction)</td></tr>
<tr class="memdesc:a97c13d6b776c998bd74286c6a8b774dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an I/O pin to a given direction.  <a href="#a97c13d6b776c998bd74286c6a8b774dd">More...</a><br /></td></tr>
<tr class="separator:a97c13d6b776c998bd74286c6a8b774dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016272b69e2e657a35621cfb815661d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a016272b69e2e657a35621cfb815661d3">set_output</a> (int pin, int state)</td></tr>
<tr class="memdesc:a016272b69e2e657a35621cfb815661d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I/O pin output register bit to either 1 or 0.  <a href="#a016272b69e2e657a35621cfb815661d3">More...</a><br /></td></tr>
<tr class="separator:a016272b69e2e657a35621cfb815661d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group I/O</div></td></tr>
<tr class="memitem:a9a59d35d804a8700b92e7637f55485c5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a9a59d35d804a8700b92e7637f55485c5">get_states</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:a9a59d35d804a8700b92e7637f55485c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get states of a contiguous group of I/O pins.  <a href="#a9a59d35d804a8700b92e7637f55485c5">More...</a><br /></td></tr>
<tr class="separator:a9a59d35d804a8700b92e7637f55485c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2876e81b935837260cf651cfeb0b0a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aef2876e81b935837260cf651cfeb0b0a">get_directions</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:aef2876e81b935837260cf651cfeb0b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get directions for a contiguous group of I/O pins.  <a href="#aef2876e81b935837260cf651cfeb0b0a">More...</a><br /></td></tr>
<tr class="separator:aef2876e81b935837260cf651cfeb0b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf84ae3d77141e0787ac6322533aa5e2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#abf84ae3d77141e0787ac6322533aa5e2">get_outputs</a> (int endPin, int startPin)</td></tr>
<tr class="memdesc:abf84ae3d77141e0787ac6322533aa5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output settings for a contiguous group of I/O pins.  <a href="#abf84ae3d77141e0787ac6322533aa5e2">More...</a><br /></td></tr>
<tr class="separator:abf84ae3d77141e0787ac6322533aa5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22a28c433f3857ca116c5286ddab33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aff22a28c433f3857ca116c5286ddab33">set_directions</a> (int endPin, int startPin, unsigned int pattern)</td></tr>
<tr class="memdesc:aff22a28c433f3857ca116c5286ddab33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set directions for a contiguous group of I/O pins.  <a href="#aff22a28c433f3857ca116c5286ddab33">More...</a><br /></td></tr>
<tr class="separator:aff22a28c433f3857ca116c5286ddab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf5fe86eb36a02d4f86df2d3ca8d84d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#acbf5fe86eb36a02d4f86df2d3ca8d84d">set_outputs</a> (int endPin, int startPin, unsigned int pattern)</td></tr>
<tr class="memdesc:acbf5fe86eb36a02d4f86df2d3ca8d84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output states for a contiguous group of I/O pins.  <a href="#acbf5fe86eb36a02d4f86df2d3ca8d84d">More...</a><br /></td></tr>
<tr class="separator:acbf5fe86eb36a02d4f86df2d3ca8d84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Timing</div></td></tr>
<tr class="memitem:a381e2d58c3d6a1f0fd8129bcc4726804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a381e2d58c3d6a1f0fd8129bcc4726804">pause</a> (int time)</td></tr>
<tr class="memdesc:a381e2d58c3d6a1f0fd8129bcc4726804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay cog from moving on to the next statement for a certain length of time.  <a href="#a381e2d58c3d6a1f0fd8129bcc4726804">More...</a><br /></td></tr>
<tr class="separator:a381e2d58c3d6a1f0fd8129bcc4726804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c171fd47bc9149c306576c349de680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a04c171fd47bc9149c306576c349de680">set_pause_dt</a> (int clockticks)</td></tr>
<tr class="memdesc:a04c171fd47bc9149c306576c349de680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set time increment for pause function.  <a href="#a04c171fd47bc9149c306576c349de680">More...</a><br /></td></tr>
<tr class="separator:a04c171fd47bc9149c306576c349de680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Timed I/O</div></td></tr>
<tr class="memitem:a20a9d97de9777b12cfd9353a83ac21cb"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a20a9d97de9777b12cfd9353a83ac21cb">count</a> (int pin, long duration)</td></tr>
<tr class="memdesc:a20a9d97de9777b12cfd9353a83ac21cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count number of low to high transitions an external input applies to an I/O pin over a certain period of time.  <a href="#a20a9d97de9777b12cfd9353a83ac21cb">More...</a><br /></td></tr>
<tr class="separator:a20a9d97de9777b12cfd9353a83ac21cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f87d0c6e5e644d9a2ad011e556de1e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a7f87d0c6e5e644d9a2ad011e556de1e8">dac_ctr</a> (int pin, int channel, int dacVal)</td></tr>
<tr class="memdesc:a7f87d0c6e5e644d9a2ad011e556de1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set D/A voltage.  <a href="#a7f87d0c6e5e644d9a2ad011e556de1e8">More...</a><br /></td></tr>
<tr class="separator:a7f87d0c6e5e644d9a2ad011e556de1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef60ed622a82bab16bea03cddc2340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af8ef60ed622a82bab16bea03cddc2340">dac_ctr_res</a> (int bits)</td></tr>
<tr class="memdesc:af8ef60ed622a82bab16bea03cddc2340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set D/A voltage resolution.  <a href="#af8ef60ed622a82bab16bea03cddc2340">More...</a><br /></td></tr>
<tr class="separator:af8ef60ed622a82bab16bea03cddc2340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37edfbadb336de010e4cfdecdeca6148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a37edfbadb336de010e4cfdecdeca6148">dac_ctr_stop</a> (void)</td></tr>
<tr class="memdesc:a37edfbadb336de010e4cfdecdeca6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the cog that's transmitting the DAC signal(s).  <a href="#a37edfbadb336de010e4cfdecdeca6148">More...</a><br /></td></tr>
<tr class="separator:a37edfbadb336de010e4cfdecdeca6148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d00871cfb358e7c1f4fea6fc5d07f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a78d00871cfb358e7c1f4fea6fc5d07f5">freqout</a> (int pin, int msTime, int frequency)</td></tr>
<tr class="memdesc:a78d00871cfb358e7c1f4fea6fc5d07f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use same cog to send square wave of a certain frequency for a certain amount of time. For set and forget with another cog, try square_wave function instead.  <a href="#a78d00871cfb358e7c1f4fea6fc5d07f5">More...</a><br /></td></tr>
<tr class="separator:a78d00871cfb358e7c1f4fea6fc5d07f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5">pwm_start</a> (unsigned int cycleMicroseconds)</td></tr>
<tr class="memdesc:a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start pulse width modulation (PWM) process in another cog.  <a href="#a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5">More...</a><br /></td></tr>
<tr class="separator:a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f683188c3dd35ee0574ff349835682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a57f683188c3dd35ee0574ff349835682">pwm_set</a> (int pin, int channel, int tHigh)</td></tr>
<tr class="memdesc:a57f683188c3dd35ee0574ff349835682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a PWM signal's high time.  <a href="#a57f683188c3dd35ee0574ff349835682">More...</a><br /></td></tr>
<tr class="separator:a57f683188c3dd35ee0574ff349835682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8f4f09d7d0222e947bea4b37fc33c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aec8f4f09d7d0222e947bea4b37fc33c2">pwm_stop</a> (void)</td></tr>
<tr class="memdesc:aec8f4f09d7d0222e947bea4b37fc33c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shut down PWM process and reclaim cog and I/O pins for other uses.  <a href="#aec8f4f09d7d0222e947bea4b37fc33c2">More...</a><br /></td></tr>
<tr class="separator:aec8f4f09d7d0222e947bea4b37fc33c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251e0a94359068f5e56682311ef4201"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ae251e0a94359068f5e56682311ef4201">pulse_in</a> (int pin, int state)</td></tr>
<tr class="memdesc:ae251e0a94359068f5e56682311ef4201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the duration of a pulse applied to an I/O pin.  <a href="#ae251e0a94359068f5e56682311ef4201">More...</a><br /></td></tr>
<tr class="separator:ae251e0a94359068f5e56682311ef4201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d62062bce6f1cb4bc03006f8463ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#af7d62062bce6f1cb4bc03006f8463ba5">pulse_out</a> (int pin, int time)</td></tr>
<tr class="memdesc:af7d62062bce6f1cb4bc03006f8463ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit a pulse with an I/O pin.  <a href="#af7d62062bce6f1cb4bc03006f8463ba5">More...</a><br /></td></tr>
<tr class="separator:af7d62062bce6f1cb4bc03006f8463ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f7522ca251c3cf3d7fd903fcdb5bbe"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ad5f7522ca251c3cf3d7fd903fcdb5bbe">rc_time</a> (int pin, int state)</td></tr>
<tr class="memdesc:ad5f7522ca251c3cf3d7fd903fcdb5bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I/O pin to input and measure the time it takes a signal to transition from a start state to the opposite state.  <a href="#ad5f7522ca251c3cf3d7fd903fcdb5bbe">More...</a><br /></td></tr>
<tr class="separator:ad5f7522ca251c3cf3d7fd903fcdb5bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521dea91cf2ba911ff66d3074672316f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a521dea91cf2ba911ff66d3074672316f">square_wave</a> (int pin, int channel, int freq)</td></tr>
<tr class="memdesc:a521dea91cf2ba911ff66d3074672316f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make I/O pin transmit a repeated high/low signal at a certain frequency. High and low times are the same. Frequency can range from 1 Hz to 128 MHz.  <a href="#a521dea91cf2ba911ff66d3074672316f">More...</a><br /></td></tr>
<tr class="separator:a521dea91cf2ba911ff66d3074672316f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291bd6f5b751420d414cff05e720ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a6291bd6f5b751420d414cff05e720ec8">square_wave_stop</a> (void)</td></tr>
<tr class="memdesc:a6291bd6f5b751420d414cff05e720ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the cog that's transmitting a square wave.  <a href="#a6291bd6f5b751420d414cff05e720ec8">More...</a><br /></td></tr>
<tr class="separator:a6291bd6f5b751420d414cff05e720ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288d762194e0bad67f4f37ba43f57292"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a288d762194e0bad67f4f37ba43f57292">set_io_timeout</a> (long clockTicks)</td></tr>
<tr class="memdesc:a288d762194e0bad67f4f37ba43f57292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the timeout value for the following timed I/O functions: pulse_in, rc_time.  <a href="#a288d762194e0bad67f4f37ba43f57292">More...</a><br /></td></tr>
<tr class="separator:a288d762194e0bad67f4f37ba43f57292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b081567b4d3d054382f88c777d740e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac4b081567b4d3d054382f88c777d740e">set_io_dt</a> (long clockticks)</td></tr>
<tr class="memdesc:ac4b081567b4d3d054382f88c777d740e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time increment for the following timed I/O functions: count, pulse_in, pulse_out, rc_time.  <a href="#ac4b081567b4d3d054382f88c777d740e">More...</a><br /></td></tr>
<tr class="separator:ac4b081567b4d3d054382f88c777d740e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SPI</div></td></tr>
<tr class="memitem:a4fca5193934cbc3b7fce7bfca131302d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a4fca5193934cbc3b7fce7bfca131302d">shift_in</a> (int pinDat, int pinClk, int mode, int bits)</td></tr>
<tr class="memdesc:a4fca5193934cbc3b7fce7bfca131302d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from a synchronous serial device.  <a href="#a4fca5193934cbc3b7fce7bfca131302d">More...</a><br /></td></tr>
<tr class="separator:a4fca5193934cbc3b7fce7bfca131302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f6cd6c7f7965e057926f92a9b2fa29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a39f6cd6c7f7965e057926f92a9b2fa29">shift_out</a> (int pinDat, int pinClk, int mode, int bits, int value)</td></tr>
<tr class="memdesc:a39f6cd6c7f7965e057926f92a9b2fa29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to a synchronous serial device.  <a href="#a39f6cd6c7f7965e057926f92a9b2fa29">More...</a><br /></td></tr>
<tr class="separator:a39f6cd6c7f7965e057926f92a9b2fa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I2C</div></td></tr>
<tr class="memitem:a0f02473c77ebed4ad04f829eff27985c"><td class="memItemLeft" align="right" valign="top">i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a0f02473c77ebed4ad04f829eff27985c">i2c_newbus</a> (int sclPin, int sdaPin, int sclDrive)</td></tr>
<tr class="memdesc:a0f02473c77ebed4ad04f829eff27985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up a simple serial driver with transmit &amp; receive pins.  <a href="#a0f02473c77ebed4ad04f829eff27985c">More...</a><br /></td></tr>
<tr class="separator:a0f02473c77ebed4ad04f829eff27985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c9b83ae2e87db69fb9138c6c57f57"><td class="memItemLeft" align="right" valign="top">HUBTEXT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2d8c9b83ae2e87db69fb9138c6c57f57">i2c_out</a> (i2c *busID, int i2cAddr, int memAddr, int memAddrCount, const unsigned char *data, int dataCount)</td></tr>
<tr class="memdesc:a2d8c9b83ae2e87db69fb9138c6c57f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to device using I2C protocol.  <a href="#a2d8c9b83ae2e87db69fb9138c6c57f57">More...</a><br /></td></tr>
<tr class="separator:a2d8c9b83ae2e87db69fb9138c6c57f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4323fa7fc0f0bd7ba1163f1d8ab52a"><td class="memItemLeft" align="right" valign="top">HUBTEXT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#adf4323fa7fc0f0bd7ba1163f1d8ab52a">i2c_in</a> (i2c *busID, int i2cAddr, int memAddr, int memAddrCount, unsigned char *data, int dataCount)</td></tr>
<tr class="memdesc:adf4323fa7fc0f0bd7ba1163f1d8ab52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from device using I2C protocol.  <a href="#adf4323fa7fc0f0bd7ba1163f1d8ab52a">More...</a><br /></td></tr>
<tr class="separator:adf4323fa7fc0f0bd7ba1163f1d8ab52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7858c120d81da92771560bd50c54d6"><td class="memItemLeft" align="right" valign="top">HUBTEXT int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a7c7858c120d81da92771560bd50c54d6">i2c_busy</a> (i2c *busID, int i2cAddr)</td></tr>
<tr class="memdesc:a7c7858c120d81da92771560bd50c54d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if I2C device is busy or responding.  <a href="#a7c7858c120d81da92771560bd50c54d6">More...</a><br /></td></tr>
<tr class="separator:a7c7858c120d81da92771560bd50c54d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Propeller EEPROM</div></td></tr>
<tr class="memitem:a593162b2f71e2ad23f0a09516cf9a7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a593162b2f71e2ad23f0a09516cf9a7b4">ee_putByte</a> (unsigned char value, int addr)</td></tr>
<tr class="memdesc:a593162b2f71e2ad23f0a09516cf9a7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#a593162b2f71e2ad23f0a09516cf9a7b4">More...</a><br /></td></tr>
<tr class="separator:a593162b2f71e2ad23f0a09516cf9a7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1042df969c1f5bffa816fdf068c4ed9"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac1042df969c1f5bffa816fdf068c4ed9">ee_getByte</a> (int addr)</td></tr>
<tr class="memdesc:ac1042df969c1f5bffa816fdf068c4ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#ac1042df969c1f5bffa816fdf068c4ed9">More...</a><br /></td></tr>
<tr class="separator:ac1042df969c1f5bffa816fdf068c4ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf44a20755432a25076e28e94b809264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#adf44a20755432a25076e28e94b809264">ee_putInt</a> (int value, int addr)</td></tr>
<tr class="memdesc:adf44a20755432a25076e28e94b809264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher.  <a href="#adf44a20755432a25076e28e94b809264">More...</a><br /></td></tr>
<tr class="separator:adf44a20755432a25076e28e94b809264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ba1e74fdbc69a0578425eb5e176461"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ad5ba1e74fdbc69a0578425eb5e176461">ee_getInt</a> (int addr)</td></tr>
<tr class="memdesc:ad5ba1e74fdbc69a0578425eb5e176461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call.  <a href="#ad5ba1e74fdbc69a0578425eb5e176461">More...</a><br /></td></tr>
<tr class="separator:ad5ba1e74fdbc69a0578425eb5e176461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab958571c584ab8d846c3a8a2cb326109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ab958571c584ab8d846c3a8a2cb326109">ee_putStr</a> (unsigned char *s, int n, int addr)</td></tr>
<tr class="memdesc:ab958571c584ab8d846c3a8a2cb326109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM.  <a href="#ab958571c584ab8d846c3a8a2cb326109">More...</a><br /></td></tr>
<tr class="separator:ab958571c584ab8d846c3a8a2cb326109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3fa8a82d1bc2be0828314652debe26"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a6e3fa8a82d1bc2be0828314652debe26">ee_getStr</a> (unsigned char *s, int n, int addr)</td></tr>
<tr class="memdesc:a6e3fa8a82d1bc2be0828314652debe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM.  <a href="#a6e3fa8a82d1bc2be0828314652debe26">More...</a><br /></td></tr>
<tr class="separator:a6e3fa8a82d1bc2be0828314652debe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a9a5cd4767ffd7a82c9acd2b9485b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a10a9a5cd4767ffd7a82c9acd2b9485b2">ee_putFloat32</a> (float value, int addr)</td></tr>
<tr class="memdesc:a10a9a5cd4767ffd7a82c9acd2b9485b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#a10a9a5cd4767ffd7a82c9acd2b9485b2">More...</a><br /></td></tr>
<tr class="separator:a10a9a5cd4767ffd7a82c9acd2b9485b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da63e55d0799ab30686bf38a5f15d43"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a3da63e55d0799ab30686bf38a5f15d43">ee_getFloat32</a> (int addr)</td></tr>
<tr class="memdesc:a3da63e55d0799ab30686bf38a5f15d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value.  <a href="#a3da63e55d0799ab30686bf38a5f15d43">More...</a><br /></td></tr>
<tr class="separator:a3da63e55d0799ab30686bf38a5f15d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faa206c9a2381e34baf4473028df149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a3faa206c9a2381e34baf4473028df149">ee_config</a> (int sclPin, int sdaPin, int sclDrive)</td></tr>
<tr class="memdesc:a3faa206c9a2381e34baf4473028df149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional function for setting a custom EEPROM configuration. Other ee_ functions automatically check if the EEPROM has been initialized, and if not, they use default settings equivalent to ee_config(28, 29, 0). This function can be called before any other ee_ functions to replace those defaults with custom settings.  <a href="#a3faa206c9a2381e34baf4473028df149">More...</a><br /></td></tr>
<tr class="separator:a3faa206c9a2381e34baf4473028df149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">SD Card</div></td></tr>
<tr class="memitem:aa845f3e273a492072b625da584924f32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aa845f3e273a492072b625da584924f32">sd_mount</a> (int doPin, int clkPin, int diPin, int csPin)</td></tr>
<tr class="memdesc:aa845f3e273a492072b625da584924f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount an SD card with the minimal 4-pin interface. For <a href="html/http://learn.parallax.com" target="_blank">Parallax Learn Site</a> examples, see: <a href="html/http://learn.parallax.com/propeller-c-simple-devices/sd-card-data" target="_blank">SD Card Data</a> and <a href="html/http://learn.parallax.com/propeller-c-simple-devices/play-wav-files" target="_blank">Play WAV Files</a>.  <a href="#aa845f3e273a492072b625da584924f32">More...</a><br /></td></tr>
<tr class="separator:aa845f3e273a492072b625da584924f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multicore</div></td></tr>
<tr class="memitem:a9c5d06d96a66ec25c018b469e9c5e06b"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a9c5d06d96a66ec25c018b469e9c5e06b">cog_run</a> (void(*function)(void *par), int stacksize)</td></tr>
<tr class="memdesc:a9c5d06d96a66ec25c018b469e9c5e06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function's code in the next available cog (processor).  <a href="#a9c5d06d96a66ec25c018b469e9c5e06b">More...</a><br /></td></tr>
<tr class="separator:a9c5d06d96a66ec25c018b469e9c5e06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad260529b4817b8bc40d280053d921a9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ad260529b4817b8bc40d280053d921a9e">cog_num</a> (int *coginfo)</td></tr>
<tr class="memdesc:ad260529b4817b8bc40d280053d921a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cog ID.  <a href="#ad260529b4817b8bc40d280053d921a9e">More...</a><br /></td></tr>
<tr class="separator:ad260529b4817b8bc40d280053d921a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2cba6f29a9955c55ab239066e30e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a5b2cba6f29a9955c55ab239066e30e7f">cog_end</a> (int *coginfo)</td></tr>
<tr class="memdesc:a5b2cba6f29a9955c55ab239066e30e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">End function code running in another cog that was launched with cog_run.  <a href="#a5b2cba6f29a9955c55ab239066e30e7f">More...</a><br /></td></tr>
<tr class="separator:a5b2cba6f29a9955c55ab239066e30e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Terminal Control</div></td></tr>
<tr class="memitem:a2d5010e62531065fa13124e23dbfb176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a> (int termConst,...)</td></tr>
<tr class="memdesc:a2d5010e62531065fa13124e23dbfb176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to SimpleIDE Terminal. Examples of commands include HOME, CLS, BKSP, CRSRXY, and others. All sixteen are listed in the SimpleIDE Terminal Constants section above. Click the term_cmd link to go to the details section and see parameter descriptions and code examples.  <a href="#a2d5010e62531065fa13124e23dbfb176">More...</a><br /></td></tr>
<tr class="separator:a2d5010e62531065fa13124e23dbfb176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Calculation Extras</div></td></tr>
<tr class="memitem:a25730b861c0b0ea93e23e25c37adc29d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a25730b861c0b0ea93e23e25c37adc29d">constrainFloat</a> (float value, float min, float max)</td></tr>
<tr class="memdesc:a25730b861c0b0ea93e23e25c37adc29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains a floating point value to a range from a minimum value to a maximum value. If the value is above the max constraint, this function returns the maximum constraint value. If the value is below the min constraint, it returns the minimum constraint value. If value falls between the max and min constraints, it returns the same value that was received.  <a href="#a25730b861c0b0ea93e23e25c37adc29d">More...</a><br /></td></tr>
<tr class="separator:a25730b861c0b0ea93e23e25c37adc29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90efe9490d68fd4db304c0ac9c1574b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aa90efe9490d68fd4db304c0ac9c1574b">constrainInt</a> (int value, int min, int max)</td></tr>
<tr class="memdesc:aa90efe9490d68fd4db304c0ac9c1574b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains an integer value to a range from a minimum value to a maximum value. If the value is above the max constraint, this function returns the maximum constraint value. If the value is below the min constraint, it returns the minimum constraint value. If value falls between the max and min constraints, it returns the same value that was received.  <a href="#aa90efe9490d68fd4db304c0ac9c1574b">More...</a><br /></td></tr>
<tr class="separator:aa90efe9490d68fd4db304c0ac9c1574b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21155c6ac6136e0300141f0c1e059eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac21155c6ac6136e0300141f0c1e059eb">endianSwap</a> (void *resultAddr, void *varAddr, int byteCount)</td></tr>
<tr class="memdesc:ac21155c6ac6136e0300141f0c1e059eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take bytes in one variable at varAddr, swap their order, and store them in another variable at resultAddr. This is useful for communication with peripherals that transmit/receive bytes in multi-byte values in reverse order from how the Propeller stores it in RAM.  <a href="#ac21155c6ac6136e0300141f0c1e059eb">More...</a><br /></td></tr>
<tr class="separator:ac21155c6ac6136e0300141f0c1e059eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac796526819c70e498370d9b5ced58394"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ac796526819c70e498370d9b5ced58394">mapFloat</a> (float value, float fromMin, float fromMax, float toMin, float toMax)</td></tr>
<tr class="memdesc:ac796526819c70e498370d9b5ced58394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a floating point value from its position in one range to its corresponding. position in a different range. For example, 3.0 in a range of 0.0 to 10.0 would map to 30.0 in a range of 0.0 to 100.0. Note: In some cases, 32 bit floating point values will round slightly. For example 2.0/3.0 = 0.666667.  <a href="#ac796526819c70e498370d9b5ced58394">More...</a><br /></td></tr>
<tr class="separator:ac796526819c70e498370d9b5ced58394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2519615c155ff4d679ada82e179f59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a3b2519615c155ff4d679ada82e179f59">mapInt</a> (int value, int fromMin, int fromMax, int toMin, int toMax)</td></tr>
<tr class="memdesc:a3b2519615c155ff4d679ada82e179f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an integer value from its position in one range to its corresponding. position in a different range. For example, 3 in a range of 0 to 10 would map to 30 in a range of 0 to 100.  <a href="#a3b2519615c155ff4d679ada82e179f59">More...</a><br /></td></tr>
<tr class="separator:a3b2519615c155ff4d679ada82e179f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d81fb2f6c983b524efd3b9ea1b9635"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ae7d81fb2f6c983b524efd3b9ea1b9635">random</a> (int limitLow, int limitHigh)</td></tr>
<tr class="memdesc:ae7d81fb2f6c983b524efd3b9ea1b9635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a pseudo-random integer value that falls in a range from limitLow to limitHigh. This function uses the system clock and I/O registers to create a new seed with each call, so it is very unlikely to generate the same sequence twice in a row.  <a href="#ae7d81fb2f6c983b524efd3b9ea1b9635">More...</a><br /></td></tr>
<tr class="separator:ae7d81fb2f6c983b524efd3b9ea1b9635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Deprecated</div></td></tr>
<tr class="memitem:afbfa1cfbdb01885472e3f64d26c09ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#afbfa1cfbdb01885472e3f64d26c09ed8">mark</a> (void)</td></tr>
<tr class="memdesc:afbfa1cfbdb01885472e3f64d26c09ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current time (deprecated).  <a href="#afbfa1cfbdb01885472e3f64d26c09ed8">More...</a><br /></td></tr>
<tr class="separator:afbfa1cfbdb01885472e3f64d26c09ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba16632261a1faa89b62c8d7d11b45cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#aba16632261a1faa89b62c8d7d11b45cc">timeout</a> (int time)</td></tr>
<tr class="memdesc:aba16632261a1faa89b62c8d7d11b45cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the time against the time elapsed since mark (deprecated).  <a href="#aba16632261a1faa89b62c8d7d11b45cc">More...</a><br /></td></tr>
<tr class="separator:aba16632261a1faa89b62c8d7d11b45cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f739412d16800b58f14029279e5332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a14f739412d16800b58f14029279e5332">wait</a> (int time)</td></tr>
<tr class="memdesc:a14f739412d16800b58f14029279e5332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits a certain number of time increments from the last call to mark or wait functions (deprecated).  <a href="#a14f739412d16800b58f14029279e5332">More...</a><br /></td></tr>
<tr class="separator:a14f739412d16800b58f14029279e5332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1a8552078613643aa85fda8bd7c93076"><td class="memItemLeft" align="right" valign="top"><a id="a1a8552078613643aa85fda8bd7c93076"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a1a8552078613643aa85fda8bd7c93076">ms</a></td></tr>
<tr class="memdesc:a1a8552078613643aa85fda8bd7c93076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propeller system clock ticks in 1 millisecond (ms). <br /></td></tr>
<tr class="separator:a1a8552078613643aa85fda8bd7c93076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513d04dc00f4a627b851ffd5b660d2d9"><td class="memItemLeft" align="right" valign="top"><a id="a513d04dc00f4a627b851ffd5b660d2d9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a513d04dc00f4a627b851ffd5b660d2d9">us</a></td></tr>
<tr class="memdesc:a513d04dc00f4a627b851ffd5b660d2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propeller system clock ticks in 1 millisecond (us). <br /></td></tr>
<tr class="separator:a513d04dc00f4a627b851ffd5b660d2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private (used by simpletools library)</div></td></tr>
<tr class="memitem:a270cba7176199e76e536cc9c5ebff5b5"><td class="memItemLeft" align="right" valign="top"><a id="a270cba7176199e76e536cc9c5ebff5b5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a270cba7176199e76e536cc9c5ebff5b5">st_msTicks</a></td></tr>
<tr class="memdesc:a270cba7176199e76e536cc9c5ebff5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propeller system clock ticks in 1 millisecond. Changing this value is not recommended because it can affect library performance. <br /></td></tr>
<tr class="separator:a270cba7176199e76e536cc9c5ebff5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfda7c99c6beef44af33728448fd7ad"><td class="memItemLeft" align="right" valign="top"><a id="a8bfda7c99c6beef44af33728448fd7ad"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a8bfda7c99c6beef44af33728448fd7ad">st_usTicks</a></td></tr>
<tr class="memdesc:a8bfda7c99c6beef44af33728448fd7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propeller system clock ticks in 1 microsecond. Changing this value is not recommended because it can affect library performance. <br /></td></tr>
<tr class="separator:a8bfda7c99c6beef44af33728448fd7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b26ead266d0f73aadd8f1482a407ad5"><td class="memItemLeft" align="right" valign="top"><a id="a0b26ead266d0f73aadd8f1482a407ad5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a0b26ead266d0f73aadd8f1482a407ad5">st_iodt</a></td></tr>
<tr class="memdesc:a0b26ead266d0f73aadd8f1482a407ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock ticks in a time increment used by pulse_in, pulse_out, and rc_time. Default value is the number of system clock ticks in a microsecond = CLKFREQ/1000000. <br /></td></tr>
<tr class="separator:a0b26ead266d0f73aadd8f1482a407ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2608f553978382b7abdccfc62be3e75c"><td class="memItemLeft" align="right" valign="top"><a id="a2608f553978382b7abdccfc62be3e75c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a2608f553978382b7abdccfc62be3e75c">st_timeout</a></td></tr>
<tr class="memdesc:a2608f553978382b7abdccfc62be3e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock ticks in a time increment used by pulse_in, pulse_out, and rc_time. Default value is the number of system clock ticks in 1/4 s = CLKFREQ/4. <br /></td></tr>
<tr class="separator:a2608f553978382b7abdccfc62be3e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa540efbcc63412e456b1ec27bd6ee2"><td class="memItemLeft" align="right" valign="top"><a id="affa540efbcc63412e456b1ec27bd6ee2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#affa540efbcc63412e456b1ec27bd6ee2">st_pauseTicks</a></td></tr>
<tr class="memdesc:affa540efbcc63412e456b1ec27bd6ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock ticks in a time increment used by pause function. Default value is the number of system clock ticks in 1/1000 s = CLKFREQ/1000. <br /></td></tr>
<tr class="separator:affa540efbcc63412e456b1ec27bd6ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac788987dc5b2a211a8c84490c72979"><td class="memItemLeft" align="right" valign="top"><a id="a8ac788987dc5b2a211a8c84490c72979"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a8ac788987dc5b2a211a8c84490c72979">st_mark</a></td></tr>
<tr class="memdesc:a8ac788987dc5b2a211a8c84490c72979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable shared by mark and time_out functions. <br /></td></tr>
<tr class="separator:a8ac788987dc5b2a211a8c84490c72979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0384787b04fec1080968ce1307aa20d"><td class="memItemLeft" align="right" valign="top"><a id="ab0384787b04fec1080968ce1307aa20d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ab0384787b04fec1080968ce1307aa20d">st_buscnt</a></td></tr>
<tr class="memdesc:ab0384787b04fec1080968ce1307aa20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable used by i2c_newbus. <br /></td></tr>
<tr class="separator:ab0384787b04fec1080968ce1307aa20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fabf8be6c845a7b7500689052f3445"><td class="memItemLeft" align="right" valign="top"><a id="ab8fabf8be6c845a7b7500689052f3445"></a>
i2c *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#ab8fabf8be6c845a7b7500689052f3445">st_eeprom</a></td></tr>
<tr class="memdesc:ab8fabf8be6c845a7b7500689052f3445"><td class="mdescLeft">&#160;</td><td class="mdescRight">The busID for the Propeller Activity Board's EEPROM bus. <br /></td></tr>
<tr class="separator:ab8fabf8be6c845a7b7500689052f3445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493e381735ceb4e0d7914d91d3f0c7af"><td class="memItemLeft" align="right" valign="top"><a id="a493e381735ceb4e0d7914d91d3f0c7af"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="simpletools_8h.html#a493e381735ceb4e0d7914d91d3f0c7af">st_eeInitFlag</a></td></tr>
<tr class="memdesc:a493e381735ceb4e0d7914d91d3f0c7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization flag used by ee_ functions. <br /></td></tr>
<tr class="separator:a493e381735ceb4e0d7914d91d3f0c7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This library provides convenient functions for a variety of microcontroller I/O, timing, conversion, and communication tasks. This library also includes (and you can call functions from) <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20simpletext%20Library.html" target="blank">simpletext</a> and <a href="html/../../../Text%20Devices/libsimpletext/
Documentation%20serial%20Library.html" target="blank">serial</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Andy Lindsay</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) Parallax, Inc. 2013-2017. All Rights MIT Licensed.</dd></dl>
<p>This library provides a set of introductory functions that simplify:</p>
<ul>
<li>I/O control - convenient I/O pin monitoring and control functions </li>
<li>Timing - Delays, timeouts </li>
<li>Timed I/O - pulse generation/measurement, square waves, transition counting, RC decay, etc. </li>
<li>Analog - D/A conversion, PWM, and more. <br />
 For A/D conversion see ...Learn/Simple Libraries/Convert for A/D conversion libraries </li>
<li>Serial Communication - SPI, I2C <br />
 For half and full duplex asynchronous serial communication, see ...Learn/Simple Libraries/Text Devices </li>
<li>Memory - EEPROM, SD storage</li>
</ul>
<p>Applications include: monitoring, control and communication with simple peripherals, like lights, buttons, dials, motors, peripheral integrated circuits and prototyping with simple systems that use pulse, or serial communication. (A few examples from the very large list of devices includes: servos, ultrasonic distance sensors, accelerometers, serial liquid crystal, display, etc.)</p>
<p>Intended use: Accompanies introductory electronics, robotics and programming lessons and projects on learn.parallax.com. After these lessons, bridge lessons will be added to familiarize the programmer with standard practices used by the community for adding libraries to support and endless variety of peripherals and applications.</p>
<dl class="section user"><dt>Core Usage</dt><dd>Any of these functions, if called, will launch a process into another cog and leave it launched for set it/forget it processes:</dd></dl>
<ul>
<li>cog_run (1 cog per call) </li>
<li>squareWave (1 cog) </li>
<li>pwm (1 cog) </li>
<li>dac (1 cog)</li>
</ul>
<dl class="section user"><dt>Memory Models</dt><dd>Use with CMM or LMM.</dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.1.8 Add constrainFloat, constrainInt, mapFloat, mapInt, and random. </dd></dl>
<dl class="section user"><dt></dt><dd>1.1.7 Update pause function for up to 2,147,483,647 ms. </dd></dl>
<dl class="section user"><dt></dt><dd>0.98.2 Add term_cmd function for SimpleIDE Terminal cursor, screen, and audio control. </dd></dl>
<dl class="section user"><dt></dt><dd>0.98 fpucog floating point coprocessor no longer self-starts by default. All floating point functionality is still supported, processing just happens in the same cog. i2c_out and i2c_in char regAddr parameter changed to int memAddr. itoa removed, use sprint(charArray, "%d", intVal) to make int to ASCII conversions. st_msTicks and st_usTicks global variables are pre-initialized to the number of system clock ticks in a millisecond and microsecond for convenience in library development. Variables named us and ms are initialized to the same values for user applications. Function endianSwap added to simplify communication with devices that send/receive byte data in big endian format. </dd></dl>
<dl class="section user"><dt></dt><dd>0.97 Add cog_run and cog_end for simplified running of functioncode in other cogs. </dd></dl>
<dl class="section user"><dt></dt><dd>0.96.1 Add documentation for start_fpu_cog and stop_fpu_cog. </dd></dl>
<dl class="section user"><dt></dt><dd>0.96 ee_putStr updated to support 128 byte page writes. More corrections to ee_put for contiguous data crossing address/128 boundary. </dd></dl>
<dl class="section user"><dt></dt><dd>0.95 square_wave bug that prevented output frequency changes (fixed). </dd></dl>
<dl class="section user"><dt></dt><dd>0.94 Fixed bug in ee_put* that prevented contiguous data from crossing the EEPROM's address/128 buffer boundaries. Updated stack array to static in mstimer.c. </dd></dl>
<dl class="section user"><dt></dt><dd>0.93 i2c_newbus now uses <br />
 .../Learn/Simple Libraries/Protocol/simplei2c/<br />
 Added:<br />
 i2c_out, i2c_in to cover most common I2C applications EEPROM ee_get_* and ee_put_* changed to ee_get* and ee_put* where the * term is camel-case. </dd></dl>
<dl class="section user"><dt></dt><dd>0.92 Simpletext functionality incorporated for use of character and string I/O with both terminal and peripheral devices. Simple Text folder replaces PropGCC serial driver support for simple and full duplex serial peripherals. </dd></dl>
<dl class="section user"><dt></dt><dd>0.91 shift_in function pre-clock mode bug fixed. <br />
 <br />
 </dd></dl>
<dl class="section user"><dt>Help Improve this Library</dt><dd>Please submit bug reports, suggestions, and improvements to this code to <a href="#" onclick="location.href='mai'+'lto:'+'edi'+'to'+'r@p'+'ar'+'all'+'ax'+'.co'+'m'; return false;">edito<span style="display: none;">.nosp@m.</span>r@pa<span style="display: none;">.nosp@m.</span>ralla<span style="display: none;">.nosp@m.</span>x.co<span style="display: none;">.nosp@m.</span>m</a>. </dd></dl>

<p class="definition">Definition in file <a class="el" href="simpletools_8h_source.html">simpletools.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5b2cba6f29a9955c55ab239066e30e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2cba6f29a9955c55ab239066e30e7f">&#9670;&nbsp;</a></span>cog_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cog_end </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>coginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End function code running in another cog that was launched with cog_run. </p>
<p>This function uses the value returned by cog_run to stop a function running in another cog and free the stack space cog_run allocated with its stacksize parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*coginfo</td><td>the address returned by cog_run. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad260529b4817b8bc40d280053d921a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad260529b4817b8bc40d280053d921a9e">&#9670;&nbsp;</a></span>cog_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cog_num </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>coginfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the cog ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*coginfo</td><td>the address returned by cog_run.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cog ID number. </dd></dl>

</div>
</div>
<a id="a9c5d06d96a66ec25c018b469e9c5e06b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5d06d96a66ec25c018b469e9c5e06b">&#9670;&nbsp;</a></span>cog_run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* cog_run </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *par)&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stacksize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function's code in the next available cog (processor). </p>
<p>cog_run is designed to make launching application level functions (typically from the main file) quick and easy. All you have to do is pass a pointer to a function with no return value or parameters along with the number for extra memory to reserve. The value returned can be used to shut down the process and free up memory and a cog later by passing it to cog_end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*function</td><td>pointer to a function with no parameters or return value. Example, if your function is void myFunction(), then pass &amp;myFunction.</td></tr>
    <tr><td class="paramname">stacksize</td><td>Number of extra int variables for local variable declarations and call/return stack. This also needs to cover any local variable declarations in functions that your function calls, including library functions. Be liberal with extra stack space for prototyping, and if in doubt, 40 to whatever value you calculate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*coginfo Address of memory set aside for the cog. Make sure to save this value in a variable if you intend to stop the process later with cog_end or check which cog the process was launched into with cog_num. </dd></dl>

</div>
</div>
<a id="a25730b861c0b0ea93e23e25c37adc29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25730b861c0b0ea93e23e25c37adc29d">&#9670;&nbsp;</a></span>constrainFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float constrainFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains a floating point value to a range from a minimum value to a maximum value. If the value is above the max constraint, this function returns the maximum constraint value. If the value is below the min constraint, it returns the minimum constraint value. If value falls between the max and min constraints, it returns the same value that was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to constrain.</td></tr>
    <tr><td class="paramname">min</td><td>Minimum constraint.</td></tr>
    <tr><td class="paramname">max</td><td>Maximum constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constrained result. </dd></dl>

</div>
</div>
<a id="aa90efe9490d68fd4db304c0ac9c1574b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90efe9490d68fd4db304c0ac9c1574b">&#9670;&nbsp;</a></span>constrainInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int constrainInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains an integer value to a range from a minimum value to a maximum value. If the value is above the max constraint, this function returns the maximum constraint value. If the value is below the min constraint, it returns the minimum constraint value. If value falls between the max and min constraints, it returns the same value that was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to constrain.</td></tr>
    <tr><td class="paramname">min</td><td>Minimum constraint.</td></tr>
    <tr><td class="paramname">max</td><td>Maximum constraint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constrained result. </dd></dl>

</div>
</div>
<a id="a20a9d97de9777b12cfd9353a83ac21cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a9d97de9777b12cfd9353a83ac21cb">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count number of low to high transitions an external input applies to an I/O pin over a certain period of time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number </td></tr>
    <tr><td class="paramname">duration</td><td>Amount of time the measurement counts transitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of low to high transitions </dd></dl>

</div>
</div>
<a id="a7f87d0c6e5e644d9a2ad011e556de1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f87d0c6e5e644d9a2ad011e556de1e8">&#9670;&nbsp;</a></span>dac_ctr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dacVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set D/A voltage. </p>
<p>Launches process into another cog for up to two channels of D/A conversion on any I/O pin. Other libraries may be available that provide D/A for more channels. Check SimpleIDE/Learn/Simple Libraries/Convert for options. For more options, check obex.parallax.com.</p>
<p>This library uses another cog's counter modules (2 per cog) to perform duty modulation, which is useful for D/A conversion. The digital signal it generates will affect LED brightness. The signal can be passed through a low pass RC filter for digital to analog voltage conversion. Add an op amp buffer if it needs to drive a load.</p>
<p>Default resolution is 8 bits for output voltages ranging from 0 V to (255/256) of 3.3 V.</p>
<p>General equation is dacVal * (3.3 V/2^bits)</p>
<p>Default is 8 bits, which results in dacVal * (3.3 V/ 256), so dacVal specifies the number of 256ths of 3.3 V. You can change the resolution with the dac_ctr_res function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">channel</td><td>Use 0 or 1 to select the cog's CTRA or CTRB counter modules, which are used for D/A conversion. </td></tr>
    <tr><td class="paramname">dacVal</td><td>Number of 256ths of 3.3 V by default. Use a value from 0 (0 V) to 255 . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8ef60ed622a82bab16bea03cddc2340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef60ed622a82bab16bea03cddc2340">&#9670;&nbsp;</a></span>dac_ctr_res()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr_res </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set D/A voltage resolution. </p>
<p>Default resolution is 8-bits for output voltages ranging from 0 V to (255/256) of 3.3 V.</p>
<p>General equation is dacVal * (3.3 V/2^bits)</p>
<p>Default is 8 bits, which results in dacVal * (3.3 V/ 256), so dacVal specifies the number of 256ths of 3.3 V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>The D/A converter's resolution in bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37edfbadb336de010e4cfdecdeca6148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37edfbadb336de010e4cfdecdeca6148">&#9670;&nbsp;</a></span>dac_ctr_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dac_ctr_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the cog that's transmitting the DAC signal(s). </p>
<p>Stops any signals, lets go of any I/O pins, and reclaims the cog for other uses. </p>

</div>
</div>
<a id="a3faa206c9a2381e34baf4473028df149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faa206c9a2381e34baf4473028df149">&#9670;&nbsp;</a></span>ee_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_config </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sclPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdaPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sclDrive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional function for setting a custom EEPROM configuration. Other ee_ functions automatically check if the EEPROM has been initialized, and if not, they use default settings equivalent to ee_config(28, 29, 0). This function can be called before any other ee_ functions to replace those defaults with custom settings. </p>
<dl class="section warning"><dt>Warning</dt><dd>: If you're going to call this function, make sure to do it before calling any other ee_ functions. If one ee_ function gets called before this, it'll set up defaults, and this function cannot override them after they have been set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sclPin</td><td>Propeller I/O pin connected to the EEPROM's SCL (serial clock) pin.</td></tr>
    <tr><td class="paramname">sdaPin</td><td>Propeller I/O pin connected to the EEPROM's SDA (serial data) pin.</td></tr>
    <tr><td class="paramname">sclDrive</td><td>Use 0 for standard design where the SCL pin has a pull-up resistor, or 1 if it does not have a pull-up and needs to be driven. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1042df969c1f5bffa816fdf068c4ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1042df969c1f5bffa816fdf068c4ed9">&#9670;&nbsp;</a></span>ee_getByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ee_getByte </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a byte value from a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address that with the byte value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The byte value stored by the EEPROM at the address specified by the addr parameter. </dd></dl>

</div>
</div>
<a id="a3da63e55d0799ab30686bf38a5f15d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da63e55d0799ab30686bf38a5f15d43">&#9670;&nbsp;</a></span>ee_getFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ee_getFloat32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a 32-bit precision floating point value from a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are fetching values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manager. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the 32-bit floating point float value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The float value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a id="ad5ba1e74fdbc69a0578425eb5e176461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ba1e74fdbc69a0578425eb5e176461">&#9670;&nbsp;</a></span>ee_getInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ee_getInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an int value from a certain address in the Propeller Chip's dedicated EEPROM. If you are fetching several int values, make sure to add 4 to the addr value with each successive call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The EEPROM address with the int value that should be fetched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value The int value stored by the EEPROM at the specified address. </dd></dl>

</div>
</div>
<a id="a6e3fa8a82d1bc2be0828314652debe26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3fa8a82d1bc2be0828314652debe26">&#9670;&nbsp;</a></span>ee_getStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* ee_getStr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetch a string of byte values starting at a certain address in Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array to receive the string of bytes fetched from EEPROM.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from EEPROM to the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the array that stores the characters that were fetched. </dd></dl>

</div>
</div>
<a id="a593162b2f71e2ad23f0a09516cf9a7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593162b2f71e2ad23f0a09516cf9a7b4">&#9670;&nbsp;</a></span>ee_putByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putByte </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a byte value at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The byte value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10a9a5cd4767ffd7a82c9acd2b9485b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a9a5cd4767ffd7a82c9acd2b9485b2">&#9670;&nbsp;</a></span>ee_putFloat32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putFloat32 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a 32-bit precision floating point value at a certain address in the Propeller Chip's dedicated EEPROM. A 32-bit value occupies four bytes so if you are storing values in a sequence, make sure to add 4 to each addr parameter value. </p>
<p>Make sure that the Math box is checked in the Project Manager. In Simple View, click the Show Project Manager button in SimpleIDE's bottom-left corner. Then click the Linker tab, and check the Math Lib box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The 32-bit floating point float value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf44a20755432a25076e28e94b809264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf44a20755432a25076e28e94b809264">&#9670;&nbsp;</a></span>ee_putInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store an int value at a certain address in the Propeller Chip's dedicated EEPROM. An int value occupies four bytes, so the next value should be stored at an address value that's four bytes higher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The int value to store in EEPROM.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address where the value is to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab958571c584ab8d846c3a8a2cb326109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab958571c584ab8d846c3a8a2cb326109">&#9670;&nbsp;</a></span>ee_putStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ee_putStr </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store a string of byte values starting at a certain address in the Propeller Chip's dedicated EEPROM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Address of a char array containing the string of bytes.</td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to copy from the array.</td></tr>
    <tr><td class="paramname">addr</td><td>The EEPROM address of the first byte in the string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21155c6ac6136e0300141f0c1e059eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21155c6ac6136e0300141f0c1e059eb">&#9670;&nbsp;</a></span>endianSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void endianSwap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>resultAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>varAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take bytes in one variable at varAddr, swap their order, and store them in another variable at resultAddr. This is useful for communication with peripherals that transmit/receive bytes in multi-byte values in reverse order from how the Propeller stores it in RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*resultAddr</td><td>Address of variable to store result. Make sure it's the same type as the varAddr parameter.</td></tr>
    <tr><td class="paramname">*varAddr</td><td>Address of source variable. Accepts any variable type.</td></tr>
    <tr><td class="paramname">*byteCount</td><td>Number of bytes in the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78d00871cfb358e7c1f4fea6fc5d07f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78d00871cfb358e7c1f4fea6fc5d07f5">&#9670;&nbsp;</a></span>freqout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freqout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frequency</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use same cog to send square wave of a certain frequency for a certain amount of time. For set and forget with another cog, try square_wave function instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin that sends the frequency </td></tr>
    <tr><td class="paramname">msTime</td><td>Time in ms that the signal lasts </td></tr>
    <tr><td class="paramname">frequency</td><td>Frequency of the signal in Hz. Accepts values from 1 Hz to 128000000 Hz (128 MHz). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3e6b702137ad730e834bce8a114a550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e6b702137ad730e834bce8a114a550">&#9670;&nbsp;</a></span>get_direction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_direction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the direction of the I/O pin. </p>
<p>This function will tell you the direction of the I/O pin as seen by the cog executing it. Keep in mind that that your program might make other cogs use the I/O pin as an output, and a cog that treats a pin as an output wins over one that treats it as an input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I/O pin direction as seen by the cog that runs the function. </dd></dl>

</div>
</div>
<a id="aef2876e81b935837260cf651cfeb0b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2876e81b935837260cf651cfeb0b0a">&#9670;&nbsp;</a></span>get_directions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_directions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get directions for a contiguous group of I/O pins. </p>
<p>Get direction register states from a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>States value containing a binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a id="a1faf05ad4f74447ecbb557b4ee0c190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faf05ad4f74447ecbb557b4ee0c190e">&#9670;&nbsp;</a></span>get_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get I/O pin output state. </p>
<p>Keep in mind that this function reports the value in the output register for the cog running the function. That doesn't tell you if the I/O pin is set to input, or whether another cog is sending a different output state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In a register bit for I/O pin, either 1 or 0. </dd></dl>

</div>
</div>
<a id="abf84ae3d77141e0787ac6322533aa5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf84ae3d77141e0787ac6322533aa5e2">&#9670;&nbsp;</a></span>get_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_outputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get output settings for a contiguous group of I/O pins. </p>
<p>Get output register settings for a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pattern value containing a binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a id="a9f77582253a5ee75241615296dcf0d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f77582253a5ee75241615296dcf0d05">&#9670;&nbsp;</a></span>get_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the state of an I/O pin without setting it to input. </p>
<p>Use this function instead of input if the Propeller needs to maintain an output. For example, you can use this to monitor another cog's or counter's output signal activity on a pin. (Note: if the pin is already set to input, it will return the state the external circuit is applying, just like input.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pin's state. If the pin is an output, 1 = 3.3 V and 0 = 0 V. If the pin is an input, 1 means V &gt; 1.65 V, 0 means it's less. </dd></dl>

</div>
</div>
<a id="a9a59d35d804a8700b92e7637f55485c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a59d35d804a8700b92e7637f55485c5">&#9670;&nbsp;</a></span>get_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int get_states </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get states of a contiguous group of I/O pins. </p>
<p>This works the same as getState, but for a group of pins. It tells you the actual state of each pin, regardless of whether it's a voltage applied to input or transmitted by an output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>States value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </dd></dl>

</div>
</div>
<a id="a4d9825708f3b6cae156e4e5f1e1647f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9825708f3b6cae156e4e5f1e1647f6">&#9670;&nbsp;</a></span>high()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void high </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to output-high. </p>
<p>This function set makes the Propeller P8X32A connect the I/O pin to its positive 3.3 V supply voltage enabling it to source up to 40 mA of current (max 1 W dissipation per chip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set high. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c7858c120d81da92771560bd50c54d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7858c120d81da92771560bd50c54d6">&#9670;&nbsp;</a></span>i2c_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUBTEXT int i2c_busy </td>
          <td>(</td>
          <td class="paramtype">i2c *&#160;</td>
          <td class="paramname"><em>busID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2cAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if I2C device is busy or responding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*busID</td><td>I2C bus identifier. i2c_newbus returns this pointer.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>7 bit I2C device address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if busy, 0 if ready. </dd></dl>

</div>
</div>
<a id="adf4323fa7fc0f0bd7ba1163f1d8ab52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4323fa7fc0f0bd7ba1163f1d8ab52a">&#9670;&nbsp;</a></span>i2c_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUBTEXT int i2c_in </td>
          <td>(</td>
          <td class="paramtype">i2c *&#160;</td>
          <td class="paramname"><em>busID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2cAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memAddrCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from device using I2C protocol. </p>
<p>This function uses Simple Libraries/Protocol/libsimplei2c for clock and data line signaling. You can also use this library to create custom I2C functions. Other I2C signaling options are included in Propeller GCC. Search for i2C in the propgcc folder for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*busID</td><td>I2C bus identifier. i2c_newbus returns this pointer.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>7 bit I2C device address.</td></tr>
    <tr><td class="paramname">memAddr</td><td>Value for setting memory address pointer inside the I2C device.</td></tr>
    <tr><td class="paramname">memAddrCount</td><td>Number of bytes to use for memAddr. This value can be zero for no register or memory address data, in which case memAddr can be set to NULL.</td></tr>
    <tr><td class="paramname">*data</td><td>Pointer to bytes set aside for receiving data from the I2C device.</td></tr>
    <tr><td class="paramname">dataCount</td><td>Number of bytes in data to send. Use a positive value to load data into result variable(s) least significant byte first, or a negative value for most significant byte first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of bytes written. Should be 1 + memAddrCount + dataCount. </dd></dl>

</div>
</div>
<a id="a0f02473c77ebed4ad04f829eff27985c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f02473c77ebed4ad04f829eff27985c">&#9670;&nbsp;</a></span>i2c_newbus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c* i2c_newbus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sclPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sdaPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sclDrive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up a simple serial driver with transmit &amp; receive pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sclPin</td><td>the I2C bus' serial clock pin.</td></tr>
    <tr><td class="paramname">sdaPin</td><td>the I2C bus' serial data pin.</td></tr>
    <tr><td class="paramname">sclDrive</td><td>sets I/O pin connected to SCL line to send high signals by either (sclDrive = 0) allowing the pull-up resistor on the bus to pull the line high, or (sclDrive = 1) by setting the I/O pin to output and driving the line high. sclDrive = 0 is by far the most common arrangement. sclDrive = 1 is used with some Propeller boards that do not have a pull-up resistor on the EEPROM's SCL line.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>busID - a pointer to the I2C bus info in memory. The busID value gets passed to i2c_out, i2c_in, and i2c_busy's busID parameter to select which I2C bus to use. </dd></dl>

</div>
</div>
<a id="a2d8c9b83ae2e87db69fb9138c6c57f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8c9b83ae2e87db69fb9138c6c57f57">&#9670;&nbsp;</a></span>i2c_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUBTEXT int i2c_out </td>
          <td>(</td>
          <td class="paramtype">i2c *&#160;</td>
          <td class="paramname"><em>busID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i2cAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memAddrCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dataCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to device using I2C protocol. </p>
<p>This function uses Simple Libraries/Protocol/libsimplei2c for clock and data line signaling. You can also use this library to create custom I2C functions. Other I2C signaling options are included in Propeller GCC. Search for i2C in the propgcc folder for more info.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*busID</td><td>I2C bus identifier. i2c_newbus returns this pointer.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>7 bit I2C device address.</td></tr>
    <tr><td class="paramname">memAddr</td><td>Value for setting memory address pointer inside the I2C device.</td></tr>
    <tr><td class="paramname">memAddrCount</td><td>Number of bytes to use for memAddr. This value can be zero for no register or memory address data, in which case memAddr can be set to NULL.</td></tr>
    <tr><td class="paramname">*data</td><td>Pointer to bytes to send to the I2C device.</td></tr>
    <tr><td class="paramname">dataCount</td><td>Number of bytes in data to send. Use a positive value to transmit least significant byte first, or a negative value to transmit most significant byte first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>total number of bytes written. Should be 1 + memAddrCount + dataCount. </dd></dl>

</div>
</div>
<a id="af2b2c5f5c8559b5f2957239f2c2e663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b2c5f5c8559b5f2957239f2c2e663d">&#9670;&nbsp;</a></span>input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int input </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to input and return 1 if pin detects a high signal, or 0 if it detects low. </p>
<p>This function makes the Propeller connect the I/O pin to its input buffer so that it can return the binary value of the voltage applied by an external circuit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set to input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to indicate high (above 1.65 V) received or 0 to indicate low (below 1.65 V) received. </dd></dl>

</div>
</div>
<a id="ab6b4677f42acfb2273127492d13a7e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b4677f42acfb2273127492d13a7e05">&#9670;&nbsp;</a></span>low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void low </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to output-low. </p>
<p>This function makes the Propeller P8X32A connect the I/O pin to its ground 0 V supply voltage enabling it to sink up to 40 mA of current (max 1 W dissipation per chip).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Number of the I/O pin to set low. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac796526819c70e498370d9b5ced58394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac796526819c70e498370d9b5ced58394">&#9670;&nbsp;</a></span>mapFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mapFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fromMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fromMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>toMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>toMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps a floating point value from its position in one range to its corresponding. position in a different range. For example, 3.0 in a range of 0.0 to 10.0 would map to 30.0 in a range of 0.0 to 100.0. Note: In some cases, 32 bit floating point values will round slightly. For example 2.0/3.0 = 0.666667. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to map.</td></tr>
    <tr><td class="paramname">fromMin</td><td>Minimum in value's range.</td></tr>
    <tr><td class="paramname">fromMax</td><td>Maxiumum in value's range.</td></tr>
    <tr><td class="paramname">toMin</td><td>New range's minimum.</td></tr>
    <tr><td class="paramname">toMax</td><td>New ranges maximum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A result with a position in the new range that's equivalent to value's position in its range. </dd></dl>

</div>
</div>
<a id="a3b2519615c155ff4d679ada82e179f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2519615c155ff4d679ada82e179f59">&#9670;&nbsp;</a></span>mapInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mapInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fromMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>toMax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps an integer value from its position in one range to its corresponding. position in a different range. For example, 3 in a range of 0 to 10 would map to 30 in a range of 0 to 100. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to map.</td></tr>
    <tr><td class="paramname">fromMin</td><td>Minimum in value's range.</td></tr>
    <tr><td class="paramname">fromMax</td><td>Maximum in value's range.</td></tr>
    <tr><td class="paramname">toMin</td><td>New range's minimum.</td></tr>
    <tr><td class="paramname">toMax</td><td>New ranges maximum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A result with a position in the new range that's equivalent to value's position in its range. </dd></dl>

</div>
</div>
<a id="afbfa1cfbdb01885472e3f64d26c09ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfa1cfbdb01885472e3f64d26c09ed8">&#9670;&nbsp;</a></span>mark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mark </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the current time (deprecated). </p>
<p>The timeout function uses the marked time to determine if a timeout has occurred.</p>
<dl class="section note"><dt>Note</dt><dd>This function has been deprecated because it doesn't support use in more than one cog. Use this code instead:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// CNT stores current number of system clock ticks elapsed.</span></div><div class="line"><span class="keywordtype">int</span> t = CNT;           <span class="comment">// Mark current time by storing in variable</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a381e2d58c3d6a1f0fd8129bcc4726804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381e2d58c3d6a1f0fd8129bcc4726804">&#9670;&nbsp;</a></span>pause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pause </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay cog from moving on to the next statement for a certain length of time. </p>
<p>The default time increment is 1 ms, so pause(100) would delay for 100 ms = 1/10th of a second. This time increment can be changed with a call to the set_pause_dt function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The number of time increments to delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae251e0a94359068f5e56682311ef4201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae251e0a94359068f5e56682311ef4201">&#9670;&nbsp;</a></span>pulse_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long pulse_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the duration of a pulse applied to an I/O pin. </p>
<p>Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number </td></tr>
    <tr><td class="paramname">state</td><td>State of the pulse (1 for positive or high pulses, 0 for negative or low pulses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of time units the pulse lasted. </dd></dl>

</div>
</div>
<a id="af7d62062bce6f1cb4bc03006f8463ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d62062bce6f1cb4bc03006f8463ba5">&#9670;&nbsp;</a></span>pulse_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pulse_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit a pulse with an I/O pin. </p>
<p>Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function. The pulse will be positive if the I/O pin is transmitting a low signal before the call. The pulse will be negative if it transmits a high signal before the call. When the pulse is done, the pin returns to whatever state it was in before the pulse. If the pin was an input, it will be changed to output and use whatever value was in the output register bit for the pin. This defaults to low on start-up, but you can pre-set it while leaving the pin set to input with the set_output function (or check it with get_output).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">time</td><td>Amount of time the pulse lasts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f683188c3dd35ee0574ff349835682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f683188c3dd35ee0574ff349835682">&#9670;&nbsp;</a></span>pwm_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pwm_set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a PWM signal's high time. </p>
<p>After a single call to pwm_start, this function allows you to set a PWM signal's high time. For example, if your pwm_start call sets up 1000 us (1 ms) you could use this function to make the signal high for 3/4 of its cycle with pwm_set(pin, channel, 750). If the signal goes to a DC motor through an H bridge or other driver circuit, the motor will behave as though it's only getting 3/4 of the supply and turn at roughly 3/4 of full speed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin to send the PWM signal. You can change this value on the fly, which is useful for speed control of a DC motor in two different directions. When the PWM signal changes to a new pin, the cog sets the previous pin to input. If you want it to stay low when the PWM cog lets go, just set the pin low in your code before calling pwm_start.</td></tr>
    <tr><td class="paramname">channel</td><td>You have options of 0 or 1 for up to two simultaneous PWM signals. If you have an application in mind that requires more PWM signals, check the SimpleIDE/Learn/Simple Libraries/Motor directory, and also online at obex.parallax.com.</td></tr>
    <tr><td class="paramname">tHigh</td><td>The high time for each PWM cycle repetition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccfd8aa1b8c5e7d58ee2dbfa3ecebe5">&#9670;&nbsp;</a></span>pwm_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pwm_start </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cycleMicroseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start pulse width modulation (PWM) process in another cog. </p>
<p>Great for DC motors, can also be used for servos, but the servo library is probably a better choice for that.</p>
<p>A PWM signal sends repeated high signals with a fixed cycle time. Your code will typically control the amount of time a PWM signal is high during each cycle. For example, pwm_start(1000) will establish a 1000 us PWM cycle. You can then use the pwm_set function to send high signals that last anywhere from 0 to 1000 us.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycleMicroseconds</td><td>Number of microseconds the PWM cycle lasts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec8f4f09d7d0222e947bea4b37fc33c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8f4f09d7d0222e947bea4b37fc33c2">&#9670;&nbsp;</a></span>pwm_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pwm_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shut down PWM process and reclaim cog and I/O pins for other uses. </p>
<p>Shut down PWM process and reclaim cog and I/O pins for other uses </p>

</div>
</div>
<a id="ae7d81fb2f6c983b524efd3b9ea1b9635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d81fb2f6c983b524efd3b9ea1b9635">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limitLow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>limitHigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a pseudo-random integer value that falls in a range from limitLow to limitHigh. This function uses the system clock and I/O registers to create a new seed with each call, so it is very unlikely to generate the same sequence twice in a row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limitLow</td><td>Minimum limit in the random number's range.</td></tr>
    <tr><td class="paramname">limitHigh</td><td>Maximum limit in the random number's range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pseudo-random number within the defined range. </dd></dl>

</div>
</div>
<a id="ad5f7522ca251c3cf3d7fd903fcdb5bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f7522ca251c3cf3d7fd903fcdb5bbe">&#9670;&nbsp;</a></span>rc_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long rc_time </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I/O pin to input and measure the time it takes a signal to transition from a start state to the opposite state. </p>
<p>Named rc_time because it is often used to measure a resistor-capacitor circuit's tendency to "decay" to either ground or 5 V (depending on wiring). Default time increments are specified in 1 microsecond units. Unit size can be changed with a call to set_io_dt function. The pulse will be positive if the I/O pin is transmitting a low signal before the call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">state</td><td>Starting pin state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time from starting pin. </dd></dl>

</div>
</div>
<a id="abe4291907fc0563f65a1f3ed85fb878d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4291907fc0563f65a1f3ed85fb878d">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int reverse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse the direction of an I/O pin. </p>
<p>If an I/O pin's direction is set to input, this function changes it to output. If it's set to output, this function changes it to input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pin direction. </dd></dl>

</div>
</div>
<a id="aa845f3e273a492072b625da584924f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa845f3e273a492072b625da584924f32">&#9670;&nbsp;</a></span>sd_mount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sd_mount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>doPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clkPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>diPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>csPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount an SD card with the minimal 4-pin interface. For <a href="html/http://learn.parallax.com" target="_blank">Parallax Learn Site</a> examples, see: <a href="html/http://learn.parallax.com/propeller-c-simple-devices/sd-card-data" target="_blank">SD Card Data</a> and <a href="html/http://learn.parallax.com/propeller-c-simple-devices/play-wav-files" target="_blank">Play WAV Files</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">doPin</td><td>The SD card's data out pin.</td></tr>
    <tr><td class="paramname">clkPin</td><td>The SD card's clock pin.</td></tr>
    <tr><td class="paramname">diPin</td><td>The SD card's data in pin.</td></tr>
    <tr><td class="paramname">csPin</td><td>The SD card's chip select pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status 0 if successful, or an error code. </dd></dl>

</div>
</div>
<a id="a97c13d6b776c998bd74286c6a8b774dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c13d6b776c998bd74286c6a8b774dd">&#9670;&nbsp;</a></span>set_direction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_direction </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an I/O pin to a given direction. </p>
<p>This function sets an I/O pin to either output or input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number. </td></tr>
    <tr><td class="paramname">direction</td><td>I/O pin direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff22a28c433f3857ca116c5286ddab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff22a28c433f3857ca116c5286ddab33">&#9670;&nbsp;</a></span>set_directions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_directions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set directions for a contiguous group of I/O pins. </p>
<p>Set directions values in a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin. </td></tr>
    <tr><td class="paramname">pattern</td><td>Value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4b081567b4d3d054382f88c777d740e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b081567b4d3d054382f88c777d740e">&#9670;&nbsp;</a></span>set_io_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_io_dt </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>clockticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the time increment for the following timed I/O functions: count, pulse_in, pulse_out, rc_time. </p>
<p>Time increment is set in clock ticks. For example, the default of 1 us units is specified with set_io_dt(CLKFREQ/1000000). For 2 microsecond units, use set_io_dt(CLKFREQ/500000).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockticks</td><td>Number of clock ticks that represents one I/O time increment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288d762194e0bad67f4f37ba43f57292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288d762194e0bad67f4f37ba43f57292">&#9670;&nbsp;</a></span>set_io_timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_io_timeout </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>clockTicks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the timeout value for the following timed I/O functions: pulse_in, rc_time. </p>
<p>Time increment is set in clock ticks. For example, the default of 0.25 seconds is set with set_io_timeout(CLKFREQ/4). To set the timeout to 20 ms, you could use set_io_timeout(CLKFREQ/50).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockTicks</td><td>Number of clock ticks for timed I/O </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a016272b69e2e657a35621cfb815661d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016272b69e2e657a35621cfb815661d3">&#9670;&nbsp;</a></span>set_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_output </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I/O pin output register bit to either 1 or 0. </p>
<p>This function focuses on the I/O pin's output register. If you intend to use it to send high or low signals, consider using high or low functions. This function can also be used in conjunction with set_direction to send high or low signals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin to set high or low. </td></tr>
    <tr><td class="paramname">state</td><td>1 for high, 0 for low (when pin is actually set to output, which can be done with setDirection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbf5fe86eb36a02d4f86df2d3ca8d84d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf5fe86eb36a02d4f86df2d3ca8d84d">&#9670;&nbsp;</a></span>set_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_outputs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set output states for a contiguous group of I/O pins. </p>
<p>Set output states of a contiguous group of bits in the cog's output register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endPin</td><td>The highest numbered pin. </td></tr>
    <tr><td class="paramname">startPin</td><td>The lowest numbered pin. </td></tr>
    <tr><td class="paramname">pattern</td><td>Value containing the binary bit pattern. The value for startPin should be in bit-0, next in bit-1, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04c171fd47bc9149c306576c349de680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c171fd47bc9149c306576c349de680">&#9670;&nbsp;</a></span>set_pause_dt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_pause_dt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clockticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set time increment for pause function. </p>
<p>Default time increment for pause function is 1 ms. This function allows you to change that delay to custom values. For example, set_pause_dt(CLKFREQ/2000) would set it to 1/2 ms increments. To return to default 1 ms increments, use set_pause_dt(CLKFREQ/1000).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clockticks</td><td>the number of clock ticks that pause(1) will delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fca5193934cbc3b7fce7bfca131302d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fca5193934cbc3b7fce7bfca131302d">&#9670;&nbsp;</a></span>shift_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shift_in </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive data from a synchronous serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDat</td><td>Data pin. </td></tr>
    <tr><td class="paramname">pinClk</td><td>Clock pin. </td></tr>
    <tr><td class="paramname">mode</td><td>Order and orientation to clock pulse options: MSBPRE, LSBPRE, MSBPOST,LSBPOST. </td></tr>
    <tr><td class="paramname">bits</td><td>Number of binary values to transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value received from the synchronous serial device. </dd></dl>

</div>
</div>
<a id="a39f6cd6c7f7965e057926f92a9b2fa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f6cd6c7f7965e057926f92a9b2fa29">&#9670;&nbsp;</a></span>shift_out()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void shift_out </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinDat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pinClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data to a synchronous serial device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pinDat</td><td>Data pin </td></tr>
    <tr><td class="paramname">pinClk</td><td>Clock pin </td></tr>
    <tr><td class="paramname">mode</td><td>Order that bits are transmitted, either LSBFIRST or MSBFIRST. </td></tr>
    <tr><td class="paramname">bits</td><td>Number of binary values to transfer. </td></tr>
    <tr><td class="paramname">value</td><td>to transmit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a521dea91cf2ba911ff66d3074672316f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521dea91cf2ba911ff66d3074672316f">&#9670;&nbsp;</a></span>square_wave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void square_wave </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make I/O pin transmit a repeated high/low signal at a certain frequency. High and low times are the same. Frequency can range from 1 Hz to 128 MHz. </p>
<p>Uses one additional cog with up to two active channels, each with a selectable frequency. You can change transmit pins on the fly by calling this function on the same channel, but with a different pin. The previous pin will be set to input in that cog. If your code is set to output, it will not affect that setting, only the setting for the cog that is transmitting the square wave. Code in your cog, or some other cog can modulate the signal. A low signal allows the square wave to transmit, and a high signal prevents it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin that transmits square wave frequency. To stop sending the signal. and change the pin back to input, pass the pin as a negative number. </td></tr>
    <tr><td class="paramname">channel</td><td>0 or 1 selects the counter module to transmit the frequency. </td></tr>
    <tr><td class="paramname">freq</td><td>Square wave frequency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6291bd6f5b751420d414cff05e720ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6291bd6f5b751420d414cff05e720ec8">&#9670;&nbsp;</a></span>square_wave_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void square_wave_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the cog that's transmitting a square wave. </p>
<p>Stops any signals, lets go of any I/O pins, and reclaims the cog for other uses. </p>

</div>
</div>
<a id="a2d5010e62531065fa13124e23dbfb176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5010e62531065fa13124e23dbfb176">&#9670;&nbsp;</a></span>term_cmd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void term_cmd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>termConst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a command to SimpleIDE Terminal. Examples of commands include HOME, CLS, BKSP, CRSRXY, and others. All sixteen are listed in the SimpleIDE Terminal Constants section above. Click the term_cmd link to go to the details section and see parameter descriptions and code examples. </p>
<div class="fragment"><div class="line"><span class="comment">// Examples</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#a0e26ea2db1b570d1a6fe1ac180ef4541">HOME</a>);          <span class="comment">// Cursor -&gt; home (0, 0) position</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#ada59561816893aa39c4aa41f1043c554">CLS</a>);           <span class="comment">// Clear screen and send cursor HOME</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#a4f41e5dc4d1d256277cb259077da1fc6">BKSP</a>);          <span class="comment">// Backspace one character</span></div><div class="line"><span class="comment">// Position cursor 4 spaces from left and 2 rows down from top.</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#afa53bcf09725cf1948b70eaaa229a3d1">CRSRXY</a>, 4, 2);  </div><div class="line"><span class="comment">// Position cursor 4 spaces from left, but do not change row.</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#a3cf3d7ff85aa894ae161d3f7ced308f1">CRSRX</a>, 4);  </div><div class="line"><span class="comment">// Position cursor 2 rows from top, but do not change spaces</span></div><div class="line"><span class="comment">// from left.</span></div><div class="line"><a class="code" href="simpletools_8h.html#a2d5010e62531065fa13124e23dbfb176">term_cmd</a>(<a class="code" href="simpletools_8h.html#af522fc6b22b3ec6d30fa9e5462d925e5">CRSRY</a>, 2);  </div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">termConst</td><td>One of the sixteen terminal control constants listed in the SimpleIDE Terminal Constants part of the Macros section above.</td></tr>
    <tr><td class="paramname">...</td><td>No additional parameters are required for CLS, HOME, and most of the others. Only CRSRXY requires two additional parameters, and CRSRX and CRSRY require a single additional parameter. If CRSRXY is used, arguments for x (spaces from left) and y (linefeeds from top) are required. If CRSRX is used, only the x value is required, and if CRSRY is used, only the y value is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba16632261a1faa89b62c8d7d11b45cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba16632261a1faa89b62c8d7d11b45cc">&#9670;&nbsp;</a></span>timeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int timeout </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the time against the time elapsed since mark (deprecated). </p>
<p>The default time increment is 1 us, so timeout(2000) will return 1 if 2 ms or more has elapsed since mark, or 0 if it has not.</p>
<dl class="section note"><dt>Note</dt><dd>This function has been deprecated because it doesn't support use in more than one cog. Use this code instead:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// CLKFREQ stores number of system clock ticks in 1 second.</span></div><div class="line"><span class="comment">// CNT stores current number of system clock ticks elapsed.</span></div><div class="line"><span class="keywordtype">int</span> dt = CLKFREQ/2;    <span class="comment">// Pick a timeout, 1/2 a second in this case</span></div><div class="line"><span class="keywordtype">int</span> t = CNT;           <span class="comment">// Mark current time by storing in variable</span></div><div class="line"><span class="keywordflow">while</span>(CNT - t &lt; dt)    <span class="comment">// Repeat until timeout</span></div><div class="line">{</div><div class="line">  <span class="comment">// Add code repeated until time elapsed is larger than dt here.</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Number of time increments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac00aa846d252ba311694febd1100bd11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00aa846d252ba311694febd1100bd11">&#9670;&nbsp;</a></span>toggle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int toggle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Toggle the output state of the I/O pin. </p>
<p>Change I/O pin's output state from low to high or high to low. This function assumes that some other function has already set the I/O pin to output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>I/O pin number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new pin state. </dd></dl>

</div>
</div>
<a id="a14f739412d16800b58f14029279e5332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f739412d16800b58f14029279e5332">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits a certain number of time increments from the last call to mark or wait functions (deprecated). </p>
<p>The default time increment is 1 us, so wait(2000) will return wait until 2 us after the last call to mark or wait. This function automatically updates the marked time; you can call it repeatedly without having to call mark.</p>
<dl class="section note"><dt>Note</dt><dd>This function has been deprecated because it doesn't support use in more than one cog. Use this code instead:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// CLKFREQ stores number of system clock ticks in 1 second.</span></div><div class="line"><span class="comment">// CNT stores current number of system clock ticks elapsed.</span></div><div class="line"><span class="keywordtype">int</span> t = CNT;           <span class="comment">// Mark current time by storing in variable</span></div><div class="line"><span class="keywordtype">int</span> dt = CLKFREQ/10;   <span class="comment">// Pick time increment, 1/10 second in this case</span></div><div class="line"><span class="keywordflow">while</span>(1)               <span class="comment">// Repeat indefinitely</span></div><div class="line">{</div><div class="line">  <span class="comment">// Variable timed code here.  Must last less than dt.</span></div><div class="line">  waitcnt(t += dt);</div><div class="line">  <span class="comment">// Code that must start at precise intervals here.</span></div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Number of time increments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 14 2018 15:42:33 for simpletools library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
